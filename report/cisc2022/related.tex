\section{Related Works}

\subsection{Collecting System Calls}
There are several pieces of research to detect intrusions or unexpected behaviors
by collecting the system calls methods in runtime.
\textcite{10.1007/978-3-319-24858-5_8} proposed a real-time host-based intrusion
detection system in a container, which is based on system call monitoring. They use
the `strace' command to collect a behavior log to a system-call parser. Then use the
BoSC (Bag of System Calls) \cite{1495942} to classify is it a normal behavior in
the database.

The BoSC technique is a frequency-based detection tip. \textcite{1495942} defined
those distinct system calls in $\{c_1, c_2, \dots, c_n \}$, For all system call $s_i$
had been called in $c_i$ times. And they use Na\"ive Bayes classification to deduce if
it is unexpected behavior. Then the \citeauthor{10.1007/978-3-319-24858-5_8} give the false positive rate
of around 2\% in $O(S+n_k)$ epochs to the MySQL database \cite{10.1007/978-3-319-24858-5_8}.
However, the BoSC is running in user space, even though it is a background service running
on the same host kernel. It might have heavy constant time costs of copying data from
user to kernel and kernel to user by the `copy\_to\_user()' and `copy\_from\_user()' calls.

\textcite{7809699,7796855} showed the survival rate in \textcite{10.1007/978-3-319-24858-5_8}
model for some zero-day vulnerabilities in different types and numbers of machines.
\textcite{7809699,7796855} concluded that an IDS could detect and avoid mobile continually-growing
attacks efficiently by the `escaping' model with collecting system calls.

\subsection{Fine-Grained Permission Control}

The file system access control list (ACL) was defined in POSIX, which shares a naive and robust
permission model \cite{Grnbacher2003POSIXAC, 10.5555/3026877.3026930}. But after 20 years of
evolution, in the practical consideration of the Linux operating system design, it can be divided
into two permission control mechanisms: (\Rn{1}) POSIX ACL and (\Rn{2}) seccomp. Traditional
permission control is mostly controlled by ACL or similar. Many Linux secure modules (LSM) also
use ACLs for file access control\cite{Smalley2003ImplementingSA}. For example, SELinux and AppArmor
use such permission settings.

\textcite{9184912} had proposed an architecture to enforce the access
control of the image's layers. Because the docker engine does not guarantee the layers could
not be modified by the host environment. Therefore, if we give a container privileged
permission, it could modify the layers of images. The research \cite{9184912} is using
the LSM's policy table to enforce the access control of the file system in the kernel.

However, the policy engine has four types of policy conflicts: (\RN{1}) Parent-Child Conflict,
(\RN{2}) Global-Local Conflict, (\RN{3}) Lack of Authority, and  (\RN{4}) Environment does not
meet the expectation. The initial security namespace $\Phi$ is $\emptyset$. (\RN{1},
\RN{2}) will route the policy to $\Phi = \Sigma (\Phi \cap P_i), i \in \mathbb{N}, i < n$.
And the (\RN{3}, \RN{4}) is conflicted by the capabilities of that process. \textcite{217614}
give the capabilities a higher hierarchy than policy in the policy engine. Therefore
all of these conflicts will follow the capability first.

\subsubsection{Capabilities}
\label{Capabilities}
Linux provides a more detailed permission control method on the file system, which is called
capability and was proposed by \citeauthor{6234805}. We can give archives some given capabilities
without giving whole root permissions when it executes specific system calls. Otherwise, it
must be a privileged process that can bypass all permission checks in Linux kernel.

\subsection{Recently Exploited Vulnerabilities}
In this subsection, we will mention and review some `High' or `Critical' vulnerabilities
about kernel and containers in CVSS (Common Vulnerability Scoring System).
Because container is not a real virtual machine, it is an isolated process.

We ignore the CVE-2020-29389 series (CVE 306). Because those CVEs are not container or kernel's
vulnerabilities, those CVEs are issue of image default passwords. Despite those CVEs got 10.0 score,
those are trivil vulnerabilities.

\subsubsection{Five Stages of Malware}
\label{Five_stage_of_malware}
We had been inspired by the quark engine, % \footnote{\url{https://quark-engine.readthedocs.io/en/latest/}},
which is an open-source malware scoring system for Android APK files. Quark
engine had been developed from the Taiwan Criminal Law's five stages:
(\Rn{1}) Determination, (\Rn{2}) Conspiracy, (\Rn{3}) Preparation, (\Rn{4}) Start, (\Rn{5}) Practice.

We also can use these five steps and category to give the malware stage to exploit the vulnerabilities.
(\Rn{1}) Base image landing, (\Rn{2}) Derived image landing, (\Rn{3}) User landing, (\Rn{4}) Kernel landing,
(\Rn{5}) Escaping. The escaping category is the worst case of container security, because we want a
container be a container, it must has zero leakage of capsulation.

\paragraph{Base image landing}
This is the most fundamentally basic assumption or guarantee of container security.
\textcite{8473370} proposed the BoSC technique must be $S = \{\emptyset\}$ in this step. By definition, for all
container $c$ is an image $I$ in execution, that is  $c = E(I) = \{\delta, \lambda\}$. $E$ is a function to execute and
give container $c$ a description $\delta$ and a lifetime status $\lambda$.

\paragraph{Derived image landing}
It is called derive image landing if some malicious items are inserted into the final layer,
while developers are inserting the application(s) and some dependencies into image layers,
It could be performed by a malicious base, dependencies, libraries, or binaries are inserted
into the filesystem. It is often in third-party unknown source image which is integrated
and republished by some crackers.

\paragraph{User landing}
In this step, the cracker could control the normal service to do the unexpected behaviors as
normal hacking scenarios. They can drop databases \cite{halfond2006classification} , practice
the local file inclusion \cite{hassan2018saisan, whitman2011principles}, etc.
Take an online judge in a container as an example: People could write some program, compile it, and execute it
on that machine. The cracker could write some malicious program or load some shellcode in those programs,
and give the operating system to execute. This is the user landing step.

\paragraph{Kernel landing}

It is the hacker could hack the kernel
While the kernel copies data from the user and executes the user-provided malicious pattern
or the user exploits the kernel vulnerabilities, and lets that code executed in kernel mode, that is kernel landing.

\paragraph{Escaping}

This is the most critical step of these five steps because this is the final utility given by the
container. Despite the kernel landing is almost control the whole machine, it is the last container
insecure issue of breaking the containers. There are three types of escaping: (\Rn{1}) Cgroups,
(\Rn{2}) Namespaces, (\Rn{3}) Capabilities.

(\Rn{1}) The cgroup escaping showed that \textcite{10.1145/3319535.3354227} break the
cgroups' limitation and affect the other container on the same host significantly, and gain
some extra resources from the host. (\RN{2}) Because of the limitation of lengh we skip it.
The last one, (\Rn{3}) capability escaping can be overridden the capability after the kernel landing
and modify the `task struct' of the process in the kernel.

\subsubsection{Case Studies}
This paper considered the Dirty CoW \textcite{8019988, 6394426} exploits, CVE-2016-8655 series, 
and some runC exploits.

First, the Dirty CoW is a kernel vulnerability based on race condition of mmaped memory spaces.
To prevent Dirty CoW in legacy infrastructures without kernel patch, the only one solution is
giving the limitation of system calls. Second, there are found many vulnerabilities in net/packet/af\_packet.c
with unsuited capability configurations that would help hackers gain root privileges. The last
studied we had studied the runC exploits, such as CVE-2019-5736, CVE-2021-30465 etc. Those vulnerabilities
were attacking the entry point that helps containers start-up, which would modify container configurations 
to lead hacker landing and escaping to the host machine.

\subsection{Virtual Environment Performance Benchmark}
There is a trend of applications are developed or deployed into microservice in a virtual
environment since 2008. And the performance benchmark of applications in the virtual
environment becomes more and more critical.

Therefore, there are many pieces of research shows how to evaluate the performance when
using containers or the other virtual infrastructures\cite{7371699,KOZHIRBAYEV2017175,7095802,234857}.
They are comparing the throughput, latency, and QoS for memory IO, or cryptography
algorithms calculating costs.

\textcite{234857} showed the gVisor costs: $2.2\times$ system call overhead,
$2.5\times$ memory allocation latency, and $216\times$ \textbf{slower} than raw system on
complex file opening. And \textcite{KOZHIRBAYEV2017175} showed that I/O times have more
disadvantages of latency and throughput, which is compared to container and native machines.
